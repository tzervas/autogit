---
name: Release

# This workflow creates releases and publishes Docker images to GHCR.
# It runs when:
# 1. A version tag (v*.*.*) is pushed to the repository (typically by versioning workflow)
# 2. Manually triggered via workflow_dispatch (with version override option)
#
# Note: The versioning workflow creates tags automatically on PR merges to main/dev.
# This workflow then triggers on those tag pushes to create GitHub releases.
#
# Features:
# - Runs on self-hosted runners with ample resources for parallel builds
# - Automatically parses release data from last merged PR into main or dev
# - Auto-generates proper naming convention and tagging
# - Supports manual version override via workflow_dispatch
#
# Docker Images:
# - Images are pushed to GitHub Container Registry (ghcr.io)
# - Layer caching is enabled using both GHCR and GitHub Actions cache
# - Only changed layers are rebuilt and pushed for efficiency
# - Cache sources: dev images, previous releases, and dedicated cache tags
#
# For testing builds without releasing, use the "Release Test Build" workflow

on:
  push:
    tags:
      - 'v*.*.*'      # Production releases (e.g., v0.3.0)
      - 'v*.*.*-dev.*' # Development pre-releases (e.g., v0.3.1-dev.20241224)
  workflow_dispatch:
    inputs:
      source_branch:
        description: 'Branch to create release from'
        required: true
        type: choice
        options:
          - dev
          - main
        default: dev
      version_mode:
        description: 'Version selection mode'
        required: true
        type: choice
        options:
          - auto
          - manual
        default: auto
      manual_version:
        description: 'Manual version override (e.g., v0.3.0) - only used if version_mode is "manual"'
        required: false
        type: string
      create_tag:
        description: 'Create tag if it does not exist'
        required: false
        type: boolean
        default: true

jobs:
  validate-release:
    name: Validate Release Requirements
    runs-on: self-hosted
    # Only run if:
    # 1. Tag push (from versioning workflow or manual)
    # 2. Manual workflow dispatch
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) ||
      (github.event_name == 'workflow_dispatch')
    permissions:
      contents: read
      pull-requests: read
    outputs:
      should_release: ${{ steps.check_conditions.outputs.should_release }}
      source_branch: ${{ steps.check_conditions.outputs.source_branch }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.source_branch || github.ref }}

      - name: Check release conditions
        id: check_conditions
        run: |
          SHOULD_RELEASE="false"
          SOURCE_BRANCH=""

          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual dispatch - use selected branch
            SOURCE_BRANCH="${{ inputs.source_branch }}"
            SHOULD_RELEASE="true"
            echo "âœ… Manual release triggered from $SOURCE_BRANCH branch"
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Tag push (from versioning workflow or manual)
            TAG_NAME="${GITHUB_REF#refs/tags/}"

            # Determine source branch based on tag pattern
            if [[ "$TAG_NAME" == *"-dev."* ]]; then
              SOURCE_BRANCH="dev"
              echo "âœ… Development release triggered by tag push: $TAG_NAME"
            else
              SOURCE_BRANCH="main"
              echo "âœ… Production release triggered by tag push: $TAG_NAME"
            fi

            SHOULD_RELEASE="true"
          fi

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "source_branch=$SOURCE_BRANCH" >> $GITHUB_OUTPUT
          echo "Should release: $SHOULD_RELEASE"
          echo "Source branch: $SOURCE_BRANCH"

      - name: Validate manual version format
        if: github.event_name == 'workflow_dispatch' && inputs.version_mode == 'manual'
        run: |
          VERSION="${{ inputs.manual_version }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected format: vX.Y.Z (e.g., v0.2.0)"
            exit 1
          fi
          echo "âœ… Manual version format valid: $VERSION"

  create-release:
    name: Create Release
    runs-on: self-hosted
    needs: validate-release
    if: needs.validate-release.outputs.should_release == 'true'
    outputs:
      version: ${{ steps.determine_version.outputs.version }}
      release_notes: ${{ steps.generate_notes.outputs.notes }}
    permissions:
      contents: write
      pull-requests: read
      actions: write  # Required if creating tags in manual mode that might trigger workflows
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ needs.validate-release.outputs.source_branch || github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version
        id: determine_version
        run: |
          VERSION=""

          # Handle different trigger scenarios
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ inputs.version_mode }}" = "manual" ]; then
              # Manual version override
              VERSION="${{ inputs.manual_version }}"
              echo "ðŸ“ Using manual version: $VERSION"
            else
              # Auto mode - get last merged PR from selected branch
              echo "ðŸ” Auto-detecting version from last PR merged into ${{ inputs.source_branch }}..."
              if [ "${{ inputs.source_branch }}" = "main" ]; then
                # Get last PR merged into main
                PR_DATA=$(gh pr list --state merged --base main --limit 1 --json number,title,mergedAt,headRefName --jq '.[0]')
              else
                # Get last PR merged into dev
                PR_DATA=$(gh pr list --state merged --base dev --limit 1 --json number,title,mergedAt,headRefName --jq '.[0]')
              fi

              if [ -n "$PR_DATA" ] && [ "$PR_DATA" != "null" ]; then
                PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
                PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
                echo "ðŸ“‹ Last merged PR #$PR_NUMBER: $PR_TITLE"

                # Try to extract version from PR title (e.g., "Release v0.3.0" or "v0.3.0")
                EXTRACTED_VERSION=$(echo "$PR_TITLE" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")

                if [ -n "$EXTRACTED_VERSION" ]; then
                  VERSION="$EXTRACTED_VERSION"
                  echo "âœ… Extracted version from PR title: $VERSION"
                fi
              fi
            fi
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Tag push (from versioning workflow) - use the tag directly
            VERSION=${GITHUB_REF#refs/tags/}
            echo "âœ… Using version from tag: $VERSION"
          fi

          # If no version determined yet, auto-increment from latest tag
          if [ -z "$VERSION" ]; then
            echo "ðŸ”„ No version found, auto-incrementing from latest tag..."
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"

            # Parse version components
            MAJOR=$(echo "$LATEST_TAG" | sed 's/v//' | cut -d. -f1)
            MINOR=$(echo "$LATEST_TAG" | sed 's/v//' | cut -d. -f2)
            PATCH=$(echo "$LATEST_TAG" | sed 's/v//' | cut -d. -f3 | cut -d- -f1)

            # Determine increment type based on branch or commit messages
            if [ "${{ needs.validate-release.outputs.source_branch }}" = "main" ]; then
              # For main branch, check recent commits for version hints
              RECENT_COMMITS=$(git log --oneline -20)

              if echo "$RECENT_COMMITS" | grep -qiE '\b(BREAKING CHANGE|major)\b'; then
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                echo "ðŸ“ˆ Major version bump detected"
              elif echo "$RECENT_COMMITS" | grep -qiE '\b(feat|feature|minor)\b'; then
                MINOR=$((MINOR + 1))
                PATCH=0
                echo "ðŸ“ˆ Minor version bump detected"
              else
                PATCH=$((PATCH + 1))
                echo "ðŸ“ˆ Patch version bump detected"
              fi
            else
              # For dev or other branches, increment patch
              PATCH=$((PATCH + 1))
            fi

            VERSION="v$MAJOR.$MINOR.$PATCH"
            echo "âœ… Auto-generated version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Final version: $VERSION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create or verify tag
        id: create_tag
        run: |
          VERSION="${{ steps.determine_version.outputs.version }}"

          # Check if tag exists
          if git rev-parse "refs/tags/$VERSION" >/dev/null 2>&1; then
            echo "âœ… Tag $VERSION already exists"
            TAG_EXISTS="true"
          else
            if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.create_tag }}" = "false" ]; then
              echo "âŒ Tag $VERSION does not exist and create_tag is false"
              exit 1
            fi

            echo "âš ï¸  Tag $VERSION does not exist. Creating it now..."
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$VERSION" -m "Release $VERSION"
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git push origin "$VERSION"
            echo "âœ… Created and pushed tag $VERSION"
            TAG_EXISTS="false"
          fi

          echo "tag_exists=$TAG_EXISTS" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: generate_notes
        run: |
          VERSION="${{ steps.determine_version.outputs.version }}"

          # Start with header
          echo "# Release $VERSION" > release_notes.md
          echo "" >> release_notes.md

          # Add PR information if available
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "**Merged from**: PR #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}" >> release_notes.md
            echo "**Author**: @${{ github.event.pull_request.user.login }}" >> release_notes.md
            echo "" >> release_notes.md

            # Add PR body if available
            PR_BODY="${{ github.event.pull_request.body }}"
            if [ -n "$PR_BODY" ]; then
              echo "## Changes" >> release_notes.md
              echo "$PR_BODY" >> release_notes.md
              echo "" >> release_notes.md
            fi
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.version_mode }}" = "auto" ]; then
            # Get last merged PR info
            if [ "${{ inputs.source_branch }}" = "main" ]; then
              PR_DATA=$(gh pr list --state merged --base main --limit 1 --json number,title,author,body --jq '.[0]')
            else
              PR_DATA=$(gh pr list --state merged --base dev --limit 1 --json number,title,author,body --jq '.[0]')
            fi

            if [ -n "$PR_DATA" ] && [ "$PR_DATA" != "null" ]; then
              PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
              PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
              PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')
              PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')

              echo "**Based on**: PR #$PR_NUMBER - $PR_TITLE" >> release_notes.md
              echo "**Author**: @$PR_AUTHOR" >> release_notes.md
              echo "" >> release_notes.md

              if [ -n "$PR_BODY" ]; then
                echo "## Changes" >> release_notes.md
                echo "$PR_BODY" >> release_notes.md
                echo "" >> release_notes.md
              fi
            fi
          fi

          # Extract changelog for this version from CHANGELOG.md if it exists
          if [ -f "CHANGELOG.md" ]; then
            CHANGES=$(sed -n "/## \[$VERSION\]/,/## \[/p" CHANGELOG.md | sed '$d')
            if [ -n "$CHANGES" ]; then
              echo "" >> release_notes.md
              echo "## Changelog" >> release_notes.md
              echo "$CHANGES" >> release_notes.md
            fi
          fi

          echo "notes=release_notes.md" >> $GITHUB_OUTPUT
          echo "âœ… Release notes generated"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.determine_version.outputs.version }}
          name: Release ${{ steps.determine_version.outputs.version }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          generate_release_notes: true

  build-and-publish-images:
    name: Build and Publish Docker Images
    runs-on: self-hosted
    needs: create-release
    if: needs.validate-release.outputs.should_release == 'true'
    permissions:
      contents: read
      packages: write
    strategy:
      # Enable parallel builds across matrix - self-hosted runners can handle this
      fail-fast: false
      matrix:
        service: [git-server, runner-coordinator]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.validate-release.outputs.source_branch || github.sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/${{ matrix.service }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.create-release.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.create-release.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.create-release.outputs.version }}
            type=raw,value=latest
            type=sha

      - name: Build and push Docker image (with layer caching)
        uses: docker/build-push-action@v6
        with:
          context: ./services/${{ matrix.service }}
          file: ./services/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Multi-layer cache strategy for optimal build performance
          cache-from: |
            type=registry,ref=ghcr.io/${{ github.repository }}/${{ matrix.service }}:cache
            type=registry,ref=ghcr.io/${{ github.repository }}/${{ matrix.service }}:dev
            type=registry,ref=ghcr.io/${{ github.repository }}/${{ matrix.service }}:latest
            type=gha
          cache-to: |
            type=registry,ref=ghcr.io/${{ github.repository }}/${{ matrix.service }}:cache,mode=max
            type=gha,mode=max

      - name: Image published
        run: |
          echo "âœ… Published ${{ matrix.service }} image"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
