#!/bin/bash
# GitLab User Bootstrap Script
# Creates secure multi-user hierarchy with service accounts
#
# IDEMPOTENT: Safe to run multiple times - skips existing users/tokens
# OUTPUT: Credentials saved to gitlab-credentials.env (chmod 600)
#
# Threat Model:
# - Credentials only written locally, never echoed to terminal
# - Service accounts have minimal required scopes
# - Tokens have 1-year expiration (configurable)
# - Root password captured but recommend changing after setup

set -euo pipefail

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION - Edit these values as needed
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Connection settings (match deploy-clean.sh)
HOMELAB_USER="${HOMELAB_USER:-kang}"
HOMELAB_HOST="${HOMELAB_HOST:-192.168.1.170}"
DOCKER_SOCK="${DOCKER_SOCK:-unix:///run/user/1000/docker.sock}"
CONTAINER_NAME="${CONTAINER_NAME:-autogit-git-server}"

# Output file for credentials (will be chmod 600)
CREDS_FILE="${CREDS_FILE:-gitlab-credentials.env}"

# Token expiration (days from now)
TOKEN_EXPIRY_DAYS="${TOKEN_EXPIRY_DAYS:-365}"

# User definitions: USERNAME:EMAIL:ACCESS_LEVEL:IS_ADMIN
# Access levels: guest=10, reporter=20, developer=30, maintainer=40, owner=50
declare -A USERS=(
    # Human users
    ["admin"]="admin@vectorweight.com:50:true" # Full admin for day-to-day ops
    ["kang"]="kang@vectorweight.com:40:false"  # Power user / maintainer
    ["dev"]="dev@vectorweight.com:30:false"    # Regular developer

    # Service accounts (for automation)
    ["autogit-ci"]="ci@vectorweight.com:30:false"        # CI/CD pipelines
    ["autogit-api"]="api@vectorweight.com:20:false"      # External API integrations
    ["autogit-backup"]="backup@vectorweight.com:40:true" # Backup operations (needs admin)
)

# Service account token scopes (minimal required permissions)
declare -A SERVICE_TOKEN_SCOPES=(
    ["autogit-ci"]="api,read_repository,write_repository"
    ["autogit-api"]="api,read_api"
    ["autogit-backup"]="api,read_repository,sudo"
)

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCTIONS
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log() { echo "[$(date '+%H:%M:%S')] $*"; }
log_ok() { echo "[$(date '+%H:%M:%S')] âœ… $*"; }
log_skip() { echo "[$(date '+%H:%M:%S')] â­ï¸  $*"; }
log_err() { echo "[$(date '+%H:%M:%S')] âŒ $*" >&2; }

# Execute gitlab-rails runner command on remote container
gitlab_rails() {
    ssh "${HOMELAB_USER}@${HOMELAB_HOST}" \
        "export DOCKER_HOST=${DOCKER_SOCK} && docker exec ${CONTAINER_NAME} gitlab-rails runner '$1'" 2> /dev/null
}

# Check if user exists
user_exists() {
    local username="$1"
    local result
    result=$(gitlab_rails "puts User.find_by(username: '${username}').present?")
    [[ $result == "true" ]]
}

# Generate secure random password (meets GitLab policy: 12+ chars, mixed case, numbers, special)
generate_password() {
    # Generate base random string
    local base
    base=$(openssl rand -base64 24 | tr -d '/+=' | head -c 16)
    # Ensure complexity by appending guaranteed special chars and numbers
    echo "${base}@Ag${RANDOM: -4}"
}

# Calculate token expiry date
token_expiry_date() {
    date -d "+${TOKEN_EXPIRY_DAYS} days" '+%Y-%m-%d'
}

#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
#â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
    log "ğŸ” GitLab User Bootstrap"
    log "========================"
    echo ""

    # Initialize credentials file
    if [[ -f $CREDS_FILE ]]; then
        log "Backing up existing credentials to ${CREDS_FILE}.bak"
        cp "$CREDS_FILE" "${CREDS_FILE}.bak"
    fi

    cat > "$CREDS_FILE" << 'EOF'
# GitLab Credentials
# Generated by bootstrap-gitlab-users.sh
# KEEP THIS FILE SECURE - chmod 600
#
# Format: GITLAB_<TYPE>_<USERNAME>=<value>
#
EOF
    chmod 600 "$CREDS_FILE"

    # Step 1: Capture root password
    log "ğŸ“ Capturing root credentials..."

    ROOT_PASSWORD=$(ssh "${HOMELAB_USER}@${HOMELAB_HOST}" \
        "export DOCKER_HOST=${DOCKER_SOCK} && docker exec ${CONTAINER_NAME} cat /etc/gitlab/initial_root_password 2>/dev/null" \
        | grep -E '^Password:' | awk '{print $2}' || echo "")

    if [[ -n $ROOT_PASSWORD ]]; then
        echo "GITLAB_PASSWORD_root='${ROOT_PASSWORD}'" >> "$CREDS_FILE"
        log_ok "Root password captured (from initial_root_password file)"
    else
        log_skip "No initial_root_password file - root password may already be changed"
        echo "# GITLAB_PASSWORD_root=<manually set or reset via gitlab-rake>" >> "$CREDS_FILE"
    fi

    echo "" >> "$CREDS_FILE"
    echo "# Human Users" >> "$CREDS_FILE"

    # Step 2: Create human users
    log ""
    log "ğŸ‘¥ Creating user accounts..."

    for username in "${!USERS[@]}"; do
        IFS=':' read -r email _ is_admin <<< "${USERS[$username]}"

        # Skip service accounts in this loop
        if [[ $username == autogit-* ]]; then
            continue
        fi

        if user_exists "$username"; then
            log_skip "User '$username' already exists"
            echo "# GITLAB_PASSWORD_${username}=<existing - not modified>" >> "$CREDS_FILE"
        else
            password=$(generate_password)

            # Create user via Rails - must use skip_confirmation! method, not param
            result=$(gitlab_rails "
                u = User.new(
                    username: '${username}',
                    email: '${email}',
                    name: '${username^}',
                    password: '${password}',
                    password_confirmation: '${password}',
                    admin: ${is_admin}
                )
                u.skip_confirmation!
                if u.save
                    puts 'created'
                else
                    puts 'error:' + u.errors.full_messages.join(', ')
                end
            ")

            if [[ $result == "created" ]]; then
                echo "GITLAB_PASSWORD_${username}='${password}'" >> "$CREDS_FILE"
                log_ok "Created user '${username}' (admin=${is_admin})"
            else
                log_err "Failed to create '${username}': ${result}"
            fi
        fi
    done

    echo "" >> "$CREDS_FILE"
    echo "# Service Accounts" >> "$CREDS_FILE"

    # Step 3: Create service accounts with tokens
    log ""
    log "ğŸ¤– Creating service accounts..."

    EXPIRY_DATE=$(token_expiry_date)

    for username in "${!USERS[@]}"; do
        IFS=':' read -r email _ is_admin <<< "${USERS[$username]}"

        # Only process service accounts
        if [[ $username != autogit-* ]]; then
            continue
        fi

        scopes="${SERVICE_TOKEN_SCOPES[$username]:-api}"

        if user_exists "$username"; then
            log_skip "Service account '$username' already exists"
            echo "# GITLAB_TOKEN_${username//-/_}=<existing - not modified>" >> "$CREDS_FILE"
        else
            password=$(generate_password)

            # Create service account and token - must use skip_confirmation! method
            result=$(gitlab_rails "
                u = User.new(
                    username: '${username}',
                    email: '${email}',
                    name: '${username} (Service Account)',
                    password: '${password}',
                    password_confirmation: '${password}',
                    admin: ${is_admin}
                )
                u.skip_confirmation!

                if u.save
                    # Create personal access token
                    token = u.personal_access_tokens.create!(
                        name: 'bootstrap-token',
                        scopes: ['${scopes//,/', '}'],
                        expires_at: '${EXPIRY_DATE}'
                    )
                    puts token.token
                else
                    puts 'error:' + u.errors.full_messages.join(', ')
                end
            ")

            if [[ $result == error:* ]]; then
                log_err "Failed to create '${username}': ${result#error:}"
            else
                # Store both password (for emergency) and token (for automation)
                echo "GITLAB_PASSWORD_${username//-/_}='${password}'" >> "$CREDS_FILE"
                echo "GITLAB_TOKEN_${username//-/_}='${result}'" >> "$CREDS_FILE"
                log_ok "Created service account '${username}' with token (expires: ${EXPIRY_DATE})"
            fi
        fi
    done

    # Step 4: Summary
    {
        echo ""
        echo "# Generated: $(date -Iseconds)"
        echo "# Tokens expire: ${EXPIRY_DATE}"
    } >> "$CREDS_FILE"

    log ""
    log "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    log_ok "Bootstrap complete!"
    log ""
    log "ğŸ“ Credentials saved to: ${CREDS_FILE}"
    log "ğŸ”’ File permissions: $(stat -c '%a' "$CREDS_FILE")"
    log ""
    log "âš ï¸  IMPORTANT:"
    log "   1. Move credentials to password manager"
    log "   2. Delete or encrypt ${CREDS_FILE} after copying"
    log "   3. Consider changing root password via web UI"
    log "   4. Service tokens expire on ${EXPIRY_DATE}"
    log ""
}

# Run main
main "$@"
